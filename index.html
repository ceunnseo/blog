<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CEUNNSEO - Interactive Hero</title>
    <style>
        /* ========================================
           BASE STYLES
        ======================================== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            min-height: 100%;
            background: #000;
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            overflow-x: hidden;
        }

        body {
            /* Extend document height for scrolling */
            min-height: 300vh;
        }

        /* Skip to content link for accessibility */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: #fff;
            color: #000;
            padding: 8px;
            text-decoration: none;
            z-index: 100;
        }
        .skip-link:focus {
            top: 0;
        }

        /* ========================================
           CANVAS
        ======================================== */
        #hero-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            display: block;
            z-index: 1;
        }

        /* ========================================
           NAVIGATION
        ======================================== */
        nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 24px 48px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
            pointer-events: none;
        }

        nav a {
            color: #fff;
            text-decoration: none;
            font-size: 14px;
            font-weight: 300;
            letter-spacing: 0.5px;
            pointer-events: auto;
            opacity: 0.8;
            transition: opacity 0.3s;
        }

        nav a:hover {
            opacity: 1;
        }

        .nav-logo {
            font-weight: 500;
            font-size: 16px;
        }

        /* ========================================
           SCROLL INDICATOR
        ======================================== */
        .scroll-indicator {
            position: fixed;
            bottom: 32px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            opacity: 1;
            transition: opacity 0.6s;
            pointer-events: none;
        }

        .scroll-indicator.hidden {
            opacity: 0;
        }

        .scroll-text {
            font-size: 12px;
            font-weight: 300;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 8px;
            text-align: center;
        }

        .scroll-line {
            width: 1px;
            height: 40px;
            background: #fff;
            margin: 0 auto;
            animation: scrollPulse 2s ease-in-out infinite;
        }

        @keyframes scrollPulse {
            0%, 100% { opacity: 0.3; transform: scaleY(1); }
            50% { opacity: 1; transform: scaleY(1.2); }
        }

        /* ========================================
           CONTENT SECTION
        ======================================== */
        .content-section {
            position: relative;
            z-index: 2;
            margin-top: 150vh;
            padding: 80px 48px;
            max-width: 960px;
            margin-left: auto;
            margin-right: auto;
            opacity: 0;
            transform: translateY(40px);
            transition: opacity 0.8s, transform 0.8s;
        }

        .content-section.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .content-section h1 {
            font-size: 48px;
            font-weight: 700;
            margin-bottom: 24px;
            line-height: 1.2;
        }

        .content-section p {
            font-size: 18px;
            line-height: 1.8;
            margin-bottom: 16px;
            opacity: 0.8;
        }

        .content-section .highlight {
            display: inline-block;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            font-weight: 500;
        }

        /* ========================================
           RESPONSIVE
        ======================================== */
        @media (max-width: 768px) {
            nav {
                padding: 16px 24px;
            }

            .content-section {
                padding: 60px 24px;
                margin-top: 120vh;
            }

            .content-section h1 {
                font-size: 32px;
            }

            .content-section p {
                font-size: 16px;
            }
        }

        /* ========================================
           REDUCED MOTION
        ======================================== */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body>
    <!-- Accessibility -->
    <a href="#content" class="skip-link">Skip to content</a>

    <!-- Navigation -->
    <nav>
        <div class="nav-logo">CEUNNSEO</div>
        <div>
            <a href="#about">About</a>
        </div>
    </nav>

    <!-- Three.js Canvas -->
    <canvas id="hero-canvas" aria-hidden="true"></canvas>

    <!-- Scroll Indicator -->
    <div class="scroll-indicator" id="scrollIndicator">
        <div class="scroll-text">Scroll</div>
        <div class="scroll-line"></div>
    </div>

    <!-- Main Content -->
    <main id="content" class="content-section">
        <h1>Creative Developer & Designer</h1>
        <p>
            안녕하세요. 저는 <span class="highlight">CEUNNSEO</span>입니다.
            인터랙티브 웹 경험과 창의적인 디지털 솔루션을 만듭니다.
        </p>
        <p>
            Three.js, WebGL, 그리고 최신 웹 기술을 활용하여
            사용자에게 기억에 남는 경험을 제공합니다.
        </p>
        <p>
            스크롤을 통해 여정을 함께해주셔서 감사합니다.
        </p>
    </main>

    <!-- Three.js Library -->
    <script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>

    <script>
        /* ========================================
           CONFIGURATION
        ======================================== */
        const CONFIG = {
            // Particle count
            PARTICLE_COUNT: 10000,
            PARTICLE_COUNT_MOBILE: 5000,

            // Colors - 다양한 파티클 색상
            PARTICLE_COLORS: [
                0xffb3e6,  // 핑크
                0xffd9b3,  // 복숭아색
                0xffffb3,  // 노란색
                0xb3d9ff,  // 하늘색
                0xe6b3ff,  // 연보라
                0xb3ffb3   // 연두색
            ],
            BACKGROUND_COLOR: 0x000000,

            // Camera
            CAMERA_FOV: 45,
            CAMERA_START_Z: 8,
            CAMERA_END_Z: 20,

            // Animation timing (scroll progress breakpoints)
            ACT1_START: 0.00,
            ACT1_END: 0.30,
            ACT2_START: 0.30,
            ACT2_END: 0.65,
            ACT3_START: 0.65,
            ACT3_END: 1.00,

            // Mouse repulsion
            MOUSE_REPULSION_RADIUS: 2.5,
            MOUSE_REPULSION_STRENGTH: 0.5,

            // Particle drift - 더 많은 움직임
            DRIFT_SPEED: 0.001,
            DRIFT_AMOUNT: 1.2,
            ROTATION_SPEED: 0.002,

            // Door dimensions
            DOOR_WIDTH: 4,
            DOOR_HEIGHT: 7,
            DOOR_DEPTH: 0.5,

            // Performance
            USE_REDUCED_MOTION: window.matchMedia('(prefers-reduced-motion: reduce)').matches,
            IS_MOBILE: window.innerWidth < 768
        };

        /* ========================================
           GLOBAL STATE
        ======================================== */
        let scene, camera, renderer;
        let particleSystems = [];
        let startPositions = [];
        let doorPositions = [];
        let currentOffsets = [];
        let driftOffsets = [];
        let rotationOffsets = [];
        let scrollProgress = 0;
        let mouseNDC = { x: 0, y: 0 };
        let mouse3D = new THREE.Vector3();

        /* ========================================
           UTILITY FUNCTIONS
        ======================================== */

        /**
         * Clamp value between min and max
         */
        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }

        /**
         * Linear interpolation
         */
        function mix(a, b, t) {
            return a * (1 - t) + b * t;
        }

        /**
         * Smoothstep function for smooth transitions
         */
        function smoothstep(edge0, edge1, x) {
            const t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
            return t * t * (3.0 - 2.0 * t);
        }

        /**
         * Ease out cubic easing
         */
        function easeOutCubic(t) {
            return 1 - Math.pow(1 - t, 3);
        }

        /**
         * Ease out elastic for spring effect
         */
        function easeOutElastic(t) {
            const c4 = (2 * Math.PI) / 3;
            return t === 0 ? 0 : t === 1 ? 1 :
                   Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
        }

        /* ========================================
           SHAPE GEOMETRIES
        ======================================== */

        /**
         * Create circle geometry
         */
        function createCircleGeometry() {
            return new THREE.CircleGeometry(0.08, 16);
        }

        /**
         * Create heart shape geometry
         */
        function createHeartGeometry() {
            const heartShape = new THREE.Shape();
            const x = 0, y = 0;
            heartShape.moveTo(x, y);
            heartShape.bezierCurveTo(x, y - 0.3, x - 0.6, y - 0.3, x - 0.6, y);
            heartShape.bezierCurveTo(x - 0.6, y + 0.3, x, y + 0.6, x, y + 1);
            heartShape.bezierCurveTo(x, y + 0.6, x + 0.6, y + 0.3, x + 0.6, y);
            heartShape.bezierCurveTo(x + 0.6, y - 0.3, x, y - 0.3, x, y);

            const geometry = new THREE.ShapeGeometry(heartShape);
            geometry.scale(0.08, 0.08, 1);
            return geometry;
        }

        /**
         * Create star geometry
         */
        function createStarGeometry() {
            const starShape = new THREE.Shape();
            const spikes = 5;
            const outerRadius = 1;
            const innerRadius = 0.4;

            for (let i = 0; i < spikes * 2; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const angle = (i * Math.PI) / spikes;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;

                if (i === 0) {
                    starShape.moveTo(x, y);
                } else {
                    starShape.lineTo(x, y);
                }
            }
            starShape.closePath();

            const geometry = new THREE.ShapeGeometry(starShape);
            geometry.scale(0.08, 0.08, 1);
            return geometry;
        }

        /* ========================================
           DOOR SHAPE GENERATION
        ======================================== */

        /**
         * Generate door shape positions
         * Creates a mystical door with frame and center opening
         */
        function generateDoorPositions() {
            const positions = [];
            const width = CONFIG.DOOR_WIDTH;
            const height = CONFIG.DOOR_HEIGHT;
            const thickness = 0.15;
            const samples = CONFIG.IS_MOBILE ? 1500 : 2500;

            // Door frame - outer rectangle
            for (let i = 0; i < samples * 0.4; i++) {
                const t = Math.random();
                let x, y;

                // Distribute along the four sides of outer frame
                const side = Math.floor(Math.random() * 4);
                switch(side) {
                    case 0: // Top
                        x = (Math.random() - 0.5) * width;
                        y = height / 2;
                        break;
                    case 1: // Bottom
                        x = (Math.random() - 0.5) * width;
                        y = -height / 2;
                        break;
                    case 2: // Left
                        x = -width / 2;
                        y = (Math.random() - 0.5) * height;
                        break;
                    case 3: // Right
                        x = width / 2;
                        y = (Math.random() - 0.5) * height;
                        break;
                }

                positions.push({
                    x: x,
                    y: y,
                    z: 0,
                    type: 'frame'
                });
            }

            // Door panels - inner decorative elements
            const panelWidth = width * 0.35;
            const panelHeight = height * 0.35;
            const panelOffsetY = height * 0.15;

            for (let i = 0; i < samples * 0.3; i++) {
                // Top panel
                const x = (Math.random() - 0.5) * panelWidth;
                const y = (Math.random() - 0.5) * panelHeight + panelOffsetY;
                positions.push({
                    x: x,
                    y: y,
                    z: 0,
                    type: 'panel'
                });
            }

            // Door handle/center ornament
            const ornamentRadius = 0.3;
            for (let i = 0; i < samples * 0.15; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * ornamentRadius;
                const x = Math.cos(angle) * r;
                const y = Math.sin(angle) * r - panelOffsetY * 1.5;
                positions.push({
                    x: x,
                    y: y,
                    z: 0,
                    type: 'ornament'
                });
            }

            // Mystical symbols around the door
            const symbolCount = 8;
            const symbolRadius = width * 0.7;
            for (let i = 0; i < symbolCount; i++) {
                const angle = (i / symbolCount) * Math.PI * 2;
                const x = Math.cos(angle) * symbolRadius;
                const y = Math.sin(angle) * symbolRadius * 0.8;

                // Small cluster for each symbol
                for (let j = 0; j < 15; j++) {
                    const offsetX = (Math.random() - 0.5) * 0.2;
                    const offsetY = (Math.random() - 0.5) * 0.2;
                    positions.push({
                        x: x + offsetX,
                        y: y + offsetY,
                        z: 0,
                        type: 'symbol'
                    });
                }
            }

            return positions;
        }

        /* ========================================
           PARTICLE SYSTEM
        ======================================== */

        /**
         * Create particle systems with different shapes
         */
        function createParticles() {
            const particleCount = CONFIG.IS_MOBILE ?
                CONFIG.PARTICLE_COUNT_MOBILE : CONFIG.PARTICLE_COUNT;

            // Generate door target positions
            const sampledPositions = generateDoorPositions();

            // Create three types of particles: circles, hearts, and stars
            const geometries = [
                createCircleGeometry(),
                createHeartGeometry(),
                createStarGeometry()
            ];

            const particlesPerType = Math.floor(particleCount / 3);

            geometries.forEach((geometry, typeIndex) => {
                const material = new THREE.MeshBasicMaterial({
                    color: CONFIG.PARTICLE_COLORS[typeIndex % CONFIG.PARTICLE_COLORS.length],
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.8
                });

                const mesh = new THREE.InstancedMesh(
                    geometry,
                    material,
                    particlesPerType
                );
                mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                mesh.frustumCulled = false;

                const dummy = new THREE.Object3D();

                for (let i = 0; i < particlesPerType; i++) {
                    const globalIndex = typeIndex * particlesPerType + i;

                    // Random start position (scattered in 3D space)
                    const startPos = {
                        x: (Math.random() - 0.5) * 25,
                        y: (Math.random() - 0.5) * 25,
                        z: (Math.random() - 0.5) * 15
                    };
                    startPositions.push(startPos);

                    // Target position from door shape
                    const targetIndex = globalIndex % sampledPositions.length;
                    const targetPos = { ...sampledPositions[targetIndex] };
                    doorPositions.push(targetPos);

                    // Initialize current position to start position
                    dummy.position.set(startPos.x, startPos.y, startPos.z);
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);

                    // Initialize offsets
                    currentOffsets.push({ x: 0, y: 0, z: 0 });
                    driftOffsets.push({
                        speedX: (Math.random() - 0.5) * CONFIG.DRIFT_SPEED,
                        speedY: (Math.random() - 0.5) * CONFIG.DRIFT_SPEED,
                        speedZ: (Math.random() - 0.5) * CONFIG.DRIFT_SPEED,
                        x: 0,
                        y: 0,
                        z: 0
                    });
                    rotationOffsets.push({
                        speed: (Math.random() - 0.5) * CONFIG.ROTATION_SPEED,
                        angle: Math.random() * Math.PI * 2
                    });
                }

                mesh.instanceMatrix.needsUpdate = true;
                scene.add(mesh);
                particleSystems.push({ mesh, typeIndex });
            });

            console.log(`Created ${particleCount} particles across 3 shape types`);
            console.log(`Generated ${sampledPositions.length} door target positions`);
        }

        /**
         * Update particle positions based on scroll progress
         */
        function updateParticles(deltaTime) {
            if (particleSystems.length === 0) return;

            // Calculate progress for each act
            const tA = smoothstep(CONFIG.ACT1_START, CONFIG.ACT1_END, scrollProgress);
            const tB = smoothstep(CONFIG.ACT2_START, CONFIG.ACT2_END, scrollProgress);
            const tC = smoothstep(CONFIG.ACT3_START, CONFIG.ACT3_END, scrollProgress);

            // Apply easing to morph transition
            const morphProgress = CONFIG.USE_REDUCED_MOTION ? tB : easeOutCubic(tB);

            // Drift is active in Act 1
            const driftActive = CONFIG.USE_REDUCED_MOTION ? 0 : (1 - morphProgress * 0.7);

            let globalIndex = 0;

            particleSystems.forEach(({ mesh, typeIndex }) => {
                const dummy = new THREE.Object3D();
                const instanceCount = mesh.count;

                for (let i = 0; i < instanceCount; i++) {
                    const start = startPositions[globalIndex];
                    const target = doorPositions[globalIndex];
                    const drift = driftOffsets[globalIndex];
                    const rotation = rotationOffsets[globalIndex];
                    const offset = currentOffsets[globalIndex];

                    // Update drift
                    drift.x += drift.speedX * driftActive * CONFIG.DRIFT_AMOUNT;
                    drift.y += drift.speedY * driftActive * CONFIG.DRIFT_AMOUNT;
                    drift.z += drift.speedZ * driftActive * CONFIG.DRIFT_AMOUNT;

                    // Update rotation
                    rotation.angle += rotation.speed;

                    // Morph from start to target position
                    let x = mix(start.x, target.x, morphProgress);
                    let y = mix(start.y, target.y, morphProgress);
                    let z = mix(start.z, target.z, morphProgress);

                    // Add drift offset
                    x += drift.x * driftActive;
                    y += drift.y * driftActive;
                    z += drift.z * driftActive;

                    // Add mouse repulsion offset
                    x += offset.x;
                    y += offset.y;
                    z += offset.z;

                    // Apply spring overshoot effect when forming door
                    if (morphProgress > 0.7 && !CONFIG.USE_REDUCED_MOTION) {
                        const overshoot = easeOutElastic(morphProgress);
                        x = mix(start.x, target.x, overshoot) + offset.x;
                        y = mix(start.y, target.y, overshoot) + offset.y;
                    }

                    // Door opening effect in Act 3
                    if (tC > 0.1) {
                        // Particles move outward and back
                        const doorOpenProgress = easeOutCubic(tC);
                        const distance = Math.sqrt(target.x * target.x + target.y * target.y);
                        const angle = Math.atan2(target.y, target.x);

                        // Move outward then inward (creating opening effect)
                        const moveAmount = Math.sin(doorOpenProgress * Math.PI) * 3;
                        x += Math.cos(angle) * moveAmount;
                        y += Math.sin(angle) * moveAmount;
                        z += doorOpenProgress * 10; // Move towards camera (entering door)
                    }

                    // Update instance matrix
                    dummy.position.set(x, y, z);

                    // Rotation based on particle type and animation phase
                    dummy.rotation.z = rotation.angle * (1 + tC);

                    // Hearts rotate in 3D
                    if (typeIndex === 1) {
                        dummy.rotation.y = rotation.angle * 2;
                    }

                    // Stars rotate faster
                    if (typeIndex === 2) {
                        dummy.rotation.z = rotation.angle * 1.5;
                    }

                    // Scale based on Act 3 progress (fade and shrink when entering door)
                    const scale = mix(1.0, 0.1, tC);
                    dummy.scale.set(scale, scale, scale);

                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);

                    // Gradually decay offsets
                    offset.x *= 0.95;
                    offset.y *= 0.95;
                    offset.z *= 0.95;

                    globalIndex++;
                }

                mesh.instanceMatrix.needsUpdate = true;

                // Update material opacity
                const opacity = mix(0.8, 0.0, tC);
                mesh.material.opacity = opacity;
            });
        }

        /**
         * Apply mouse repulsion effect to nearby particles
         */
        function applyMouseRepulsion() {
            if (particleSystems.length === 0 || CONFIG.USE_REDUCED_MOTION) return;

            const radius = CONFIG.MOUSE_REPULSION_RADIUS;
            const strength = CONFIG.MOUSE_REPULSION_STRENGTH;
            const morphProgress = smoothstep(CONFIG.ACT2_START, CONFIG.ACT2_END, scrollProgress);

            let globalIndex = 0;

            particleSystems.forEach(({ mesh }) => {
                for (let i = 0; i < mesh.count; i++) {
                    const start = startPositions[globalIndex];
                    const target = doorPositions[globalIndex];

                    // Current position (interpolated)
                    const currentX = mix(start.x, target.x, morphProgress);
                    const currentY = mix(start.y, target.y, morphProgress);
                    const currentZ = mix(start.z, target.z, morphProgress);

                    // Distance to mouse
                    const dx = currentX - mouse3D.x;
                    const dy = currentY - mouse3D.y;
                    const dz = currentZ - mouse3D.z;
                    const distSq = dx * dx + dy * dy + dz * dz;
                    const dist = Math.sqrt(distSq);

                    if (dist < radius && dist > 0.01) {
                        // Calculate repulsion
                        const falloff = 1 - (dist / radius);
                        const force = falloff * falloff * strength;

                        currentOffsets[globalIndex].x += (dx / dist) * force;
                        currentOffsets[globalIndex].y += (dy / dist) * force;
                        currentOffsets[globalIndex].z += (dz / dist) * force;
                    }

                    globalIndex++;
                }
            });
        }

        /* ========================================
           SCROLL HANDLING
        ======================================== */

        /**
         * Update scroll progress and related UI
         */
        function updateScrollProgress() {
            const scrollY = window.scrollY || window.pageYOffset;
            const maxScroll = document.documentElement.scrollHeight - window.innerHeight;

            // Calculate normalized scroll progress [0, 1]
            scrollProgress = clamp(scrollY / maxScroll, 0, 1);

            // Hide scroll indicator after initial scroll
            const indicator = document.getElementById('scrollIndicator');
            if (scrollProgress > 0.1) {
                indicator.classList.add('hidden');
            } else {
                indicator.classList.remove('hidden');
            }

            // Show content section in Act 3
            const contentSection = document.querySelector('.content-section');
            const tC = smoothstep(CONFIG.ACT3_START, CONFIG.ACT3_END, scrollProgress);
            if (tC > 0.5) {
                contentSection.classList.add('visible');
            } else {
                contentSection.classList.remove('visible');
            }
        }

        /* ========================================
           CAMERA
        ======================================== */

        /**
         * Update camera position based on scroll
         */
        function updateCamera() {
            const tB = smoothstep(CONFIG.ACT2_START, CONFIG.ACT2_END, scrollProgress);
            const tC = smoothstep(CONFIG.ACT3_START, CONFIG.ACT3_END, scrollProgress);

            // Zoom out during Act 2, then zoom in during Act 3 (entering door)
            let targetZ = mix(CONFIG.CAMERA_START_Z, CONFIG.CAMERA_END_Z, tB);
            targetZ = mix(targetZ, CONFIG.CAMERA_START_Z - 5, tC);

            camera.position.z = targetZ;
        }

        /* ========================================
           MOUSE TRACKING
        ======================================== */

        /**
         * Update mouse position in NDC and 3D space
         */
        function onMouseMove(event) {
            // Normalize to [-1, 1]
            mouseNDC.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouseNDC.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Convert to 3D space at camera depth
            mouse3D.set(
                mouseNDC.x * (camera.position.z * Math.tan(THREE.MathUtils.degToRad(CONFIG.CAMERA_FOV / 2)) * camera.aspect),
                mouseNDC.y * (camera.position.z * Math.tan(THREE.MathUtils.degToRad(CONFIG.CAMERA_FOV / 2))),
                0
            );
        }

        /* ========================================
           RESIZE HANDLING
        ======================================== */

        /**
         * Handle window resize
         */
        function onResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            renderer.setSize(width, height);
        }

        /* ========================================
           ANIMATION LOOP
        ======================================== */

        let lastTime = 0;

        /**
         * Main animation loop
         */
        function animate(currentTime) {
            requestAnimationFrame(animate);

            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            // Update based on scroll
            updateCamera();
            updateParticles(deltaTime);
            applyMouseRepulsion();

            // Render
            renderer.render(scene, camera);
        }

        /* ========================================
           INITIALIZATION
        ======================================== */

        /**
         * Initialize Three.js scene
         */
        function initScene() {
            // Get canvas element
            const canvas = document.getElementById('hero-canvas');

            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.BACKGROUND_COLOR);

            // Create camera
            camera = new THREE.PerspectiveCamera(
                CONFIG.CAMERA_FOV,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 0, CONFIG.CAMERA_START_Z);

            // Create renderer
            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true,
                alpha: false
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // Add subtle ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            // Create particles
            createParticles();

            console.log('Scene initialized');
        }

        /* ========================================
           EVENT LISTENERS
        ======================================== */

        function setupEventListeners() {
            // Scroll
            window.addEventListener('scroll', updateScrollProgress, { passive: true });

            // Mouse move
            window.addEventListener('mousemove', onMouseMove, { passive: true });

            // Resize
            window.addEventListener('resize', onResize, { passive: true });

            // Initial scroll update
            updateScrollProgress();
        }

        /* ========================================
           ENTRY POINT
        ======================================== */

        /**
         * Initialize when DOM is ready
         */
        function init() {
            console.log('Initializing Three.js scroll hero...');
            console.log('Configuration:', CONFIG);

            initScene();
            setupEventListeners();
            animate(0);

            console.log('Animation started');
        }

        // Wait for DOM and Three.js to be ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
