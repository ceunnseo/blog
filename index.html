<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CEUNNSEO - Interactive Hero</title>
    <style>
        /* ========================================
           BASE STYLES
        ======================================== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            min-height: 100%;
            background: #000;
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            overflow-x: hidden;
        }

        body {
            /* Extend document height for scrolling */
            min-height: 300vh;
        }

        /* Skip to content link for accessibility */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: #fff;
            color: #000;
            padding: 8px;
            text-decoration: none;
            z-index: 100;
        }
        .skip-link:focus {
            top: 0;
        }

        /* ========================================
           CANVAS
        ======================================== */
        #hero-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            display: block;
            z-index: 1;
        }

        /* ========================================
           NAVIGATION
        ======================================== */
        nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 24px 48px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
            pointer-events: none;
        }

        nav a {
            color: #fff;
            text-decoration: none;
            font-size: 14px;
            font-weight: 300;
            letter-spacing: 0.5px;
            pointer-events: auto;
            opacity: 0.8;
            transition: opacity 0.3s;
        }

        nav a:hover {
            opacity: 1;
        }

        .nav-logo {
            font-weight: 500;
            font-size: 16px;
        }

        /* ========================================
           SCROLL INDICATOR
        ======================================== */
        .scroll-indicator {
            position: fixed;
            bottom: 32px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            opacity: 1;
            transition: opacity 0.6s;
            pointer-events: none;
        }

        .scroll-indicator.hidden {
            opacity: 0;
        }

        .scroll-text {
            font-size: 12px;
            font-weight: 300;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 8px;
            text-align: center;
        }

        .scroll-line {
            width: 1px;
            height: 40px;
            background: #fff;
            margin: 0 auto;
            animation: scrollPulse 2s ease-in-out infinite;
        }

        @keyframes scrollPulse {
            0%, 100% { opacity: 0.3; transform: scaleY(1); }
            50% { opacity: 1; transform: scaleY(1.2); }
        }

        /* ========================================
           CONTENT SECTION
        ======================================== */
        .content-section {
            position: relative;
            z-index: 2;
            margin-top: 150vh;
            padding: 80px 48px;
            max-width: 960px;
            margin-left: auto;
            margin-right: auto;
            opacity: 0;
            transform: translateY(40px);
            transition: opacity 0.8s, transform 0.8s;
            text-align: center;
        }

        .content-section.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .content-section h1 {
            font-size: 48px;
            font-weight: 700;
            margin-bottom: 24px;
            line-height: 1.2;
        }

        .content-section p {
            font-size: 18px;
            line-height: 1.8;
            margin-bottom: 16px;
            opacity: 0.8;
        }

        .content-section .highlight {
            display: inline-block;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            font-weight: 500;
        }

        /* ========================================
           RESPONSIVE
        ======================================== */
        @media (max-width: 768px) {
            nav {
                padding: 16px 24px;
            }

            .content-section {
                padding: 60px 24px;
                margin-top: 120vh;
            }

            .content-section h1 {
                font-size: 32px;
            }

            .content-section p {
                font-size: 16px;
            }
        }

        /* ========================================
           REDUCED MOTION
        ======================================== */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body>
    <!-- Accessibility -->
    <a href="#content" class="skip-link">Skip to content</a>

    <!-- Navigation -->
    <nav>
        <div class="nav-logo">CEUNNSEO</div>
        <div>
            <a href="#about">About</a>
        </div>
    </nav>

    <!-- Three.js Canvas -->
    <canvas id="hero-canvas" aria-hidden="true"></canvas>

    <!-- Scroll Indicator -->
    <div class="scroll-indicator" id="scrollIndicator">
        <div class="scroll-text">Scroll</div>
        <div class="scroll-line"></div>
    </div>

    <!-- Main Content -->
    <main id="content" class="content-section">
        <h1>Creative Developer & Designer</h1>
        <p>
            안녕하세요. 저는 <span class="highlight">CEUNNSEO</span>입니다.
            인터랙티브 웹 경험과 창의적인 디지털 솔루션을 만듭니다.
        </p>
        <p>
            Three.js, WebGL, 그리고 최신 웹 기술을 활용하여
            사용자에게 기억에 남는 경험을 제공합니다.
        </p>
        <p>
            스크롤을 통해 여정을 함께해주셔서 감사합니다.
        </p>
    </main>

    <!-- Three.js Library -->
    <script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>

    <script>
        /* ========================================
           CONFIGURATION
        ======================================== */
        const CONFIG = {
            // Particle count
            PARTICLE_COUNT: 8000,
            PARTICLE_COUNT_MOBILE: 4000,

            // Colors - white only
            PARTICLE_COLOR: 0xffffff,
            BACKGROUND_COLOR: 0x000000,

            // Camera
            CAMERA_FOV: 45,
            CAMERA_START_Z: 8,
            CAMERA_END_Z: 18,

            // Animation timing (scroll progress breakpoints)
            ACT1_START: 0.00,
            ACT1_END: 0.30,
            ACT2_START: 0.30,
            ACT2_END: 0.65,
            ACT3_START: 0.65,
            ACT3_END: 1.00,

            // Mouse repulsion
            MOUSE_REPULSION_RADIUS: 2.5,
            MOUSE_REPULSION_STRENGTH: 0.5,

            // Particle drift
            DRIFT_SPEED: 0.001,
            DRIFT_AMOUNT: 1.2,
            ROTATION_SPEED: 0.002,

            // Circle dimensions
            CIRCLE_RADIUS: 3,

            // Camera rotation
            ROTATION_SENSITIVITY: 0.002,  // Reduced from 0.005 for slower, less dizzying rotation
            ROTATION_DAMPING: 0.9,        // Reduced from 0.95 for faster stop

            // Performance
            USE_REDUCED_MOTION: window.matchMedia('(prefers-reduced-motion: reduce)').matches,
            IS_MOBILE: window.innerWidth < 768
        };

        // JavaScript syntax tokens
        const JS_TOKENS = [
            'const', 'let', 'var', 'function', 'return',
            'if', 'else', 'for', 'while', 'do',
            'switch', 'case', 'break', 'continue',
            'class', 'extends', 'new', 'this',
            'import', 'export', 'from', 'as',
            'async', 'await', 'Promise', 'then',
            'try', 'catch', 'throw', 'finally',
            '=>', '{}', '[]', '()', '.',
            ';', ':', '=', '==', '===',
            '!', '!=', '!==', '&&', '||',
            '+', '-', '*', '/', '%',
            '<', '>', '<=', '>=',
            '?', 'null', 'undefined', 'true', 'false'
        ];

        /* ========================================
           GLOBAL STATE
        ======================================== */
        let scene, camera, renderer;
        let particleSprites = [];
        let startPositions = [];
        let circlePositions = [];
        let currentOffsets = [];
        let driftOffsets = [];
        let rotationOffsets = [];
        let scrollProgress = 0;
        let mouseNDC = { x: 0, y: 0 };
        let mouse3D = new THREE.Vector3();

        // Camera rotation state (spherical coordinates)
        let cameraTheta = 0;          // Horizontal rotation (azimuth)
        let cameraPhi = Math.PI / 2;  // Vertical rotation (polar) - start at equator
        let cameraRadius = CONFIG.CAMERA_START_Z;
        let cameraThetaVelocity = 0;
        let cameraPhiVelocity = 0;

        // Mouse drag state
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        /* ========================================
           UTILITY FUNCTIONS
        ======================================== */

        /**
         * Clamp value between min and max
         */
        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }

        /**
         * Linear interpolation
         */
        function mix(a, b, t) {
            return a * (1 - t) + b * t;
        }

        /**
         * Smoothstep function for smooth transitions
         */
        function smoothstep(edge0, edge1, x) {
            const t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
            return t * t * (3.0 - 2.0 * t);
        }

        /**
         * Ease out cubic easing
         */
        function easeOutCubic(t) {
            return 1 - Math.pow(1 - t, 3);
        }

        /**
         * Ease out elastic for spring effect
         */
        function easeOutElastic(t) {
            const c4 = (2 * Math.PI) / 3;
            return t === 0 ? 0 : t === 1 ? 1 :
                   Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
        }

        /* ========================================
           TEXT PLANE CREATION
        ======================================== */

        /**
         * Create a 3D text plane (not billboard sprite)
         */
        function createTextPlane(text) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');

            // Set canvas size
            canvas.width = 256;
            canvas.height = 128;

            // Configure text rendering
            context.fillStyle = 'rgba(0, 0, 0, 0)';
            context.fillRect(0, 0, canvas.width, canvas.height);

            context.font = 'bold 48px monospace';
            context.fillStyle = '#ffffff';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            // Create texture from canvas
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            // Create plane geometry instead of sprite
            const geometry = new THREE.PlaneGeometry(0.5, 0.25);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide  // Visible from both sides
            });

            // Create mesh
            const mesh = new THREE.Mesh(geometry, material);

            // Random initial rotation for 3D effect
            mesh.rotation.x = Math.random() * Math.PI * 2;
            mesh.rotation.y = Math.random() * Math.PI * 2;
            mesh.rotation.z = Math.random() * Math.PI * 2;

            return mesh;
        }

        /* ========================================
           CIRCLE SHAPE GENERATION
        ======================================== */

        /**
         * Generate circle positions (sphere surface)
         */
        function generateCirclePositions() {
            const positions = [];
            const radius = CONFIG.CIRCLE_RADIUS;
            const samples = CONFIG.IS_MOBILE ? 1500 : 2500;

            // Fibonacci sphere distribution for even point distribution
            const phi = Math.PI * (3 - Math.sqrt(5)); // Golden angle

            for (let i = 0; i < samples; i++) {
                const y = 1 - (i / (samples - 1)) * 2; // y goes from 1 to -1
                const radiusAtY = Math.sqrt(1 - y * y); // radius at y
                const theta = phi * i; // golden angle increment

                const x = Math.cos(theta) * radiusAtY;
                const z = Math.sin(theta) * radiusAtY;

                positions.push({
                    x: x * radius,
                    y: y * radius,
                    z: z * radius
                });
            }

            return positions;
        }

        /* ========================================
           PARTICLE SYSTEM
        ======================================== */

        /**
         * Create particle system with 3D text planes
         */
        function createParticles() {
            const particleCount = CONFIG.IS_MOBILE ?
                CONFIG.PARTICLE_COUNT_MOBILE : CONFIG.PARTICLE_COUNT;

            // Generate circle target positions
            const sampledPositions = generateCirclePositions();

            for (let i = 0; i < particleCount; i++) {
                // Random token from JS_TOKENS
                const token = JS_TOKENS[Math.floor(Math.random() * JS_TOKENS.length)];

                // Create 3D text plane
                const sprite = createTextPlane(token);

                // Random start position (scattered in 3D space)
                const startPos = {
                    x: (Math.random() - 0.5) * 25,
                    y: (Math.random() - 0.5) * 25,
                    z: (Math.random() - 0.5) * 15
                };
                startPositions.push(startPos);

                // Target position from circle shape
                const targetIndex = i % sampledPositions.length;
                const targetPos = { ...sampledPositions[targetIndex] };
                circlePositions.push(targetPos);

                // Set initial position
                sprite.position.set(startPos.x, startPos.y, startPos.z);

                // Initialize offsets
                currentOffsets.push({ x: 0, y: 0, z: 0 });
                driftOffsets.push({
                    speedX: (Math.random() - 0.5) * CONFIG.DRIFT_SPEED,
                    speedY: (Math.random() - 0.5) * CONFIG.DRIFT_SPEED,
                    speedZ: (Math.random() - 0.5) * CONFIG.DRIFT_SPEED,
                    x: 0,
                    y: 0,
                    z: 0
                });
                rotationOffsets.push({
                    speedX: (Math.random() - 0.5) * CONFIG.ROTATION_SPEED,
                    speedY: (Math.random() - 0.5) * CONFIG.ROTATION_SPEED,
                    speedZ: (Math.random() - 0.5) * CONFIG.ROTATION_SPEED
                });

                scene.add(sprite);
                particleSprites.push(sprite);
            }

            console.log(`Created ${particleCount} text particles`);
            console.log(`Generated ${sampledPositions.length} circle target positions`);
        }

        /**
         * Update particle positions based on scroll progress
         */
        function updateParticles(deltaTime) {
            if (particleSprites.length === 0) return;

            // Calculate progress for each act
            const tA = smoothstep(CONFIG.ACT1_START, CONFIG.ACT1_END, scrollProgress);
            const tB = smoothstep(CONFIG.ACT2_START, CONFIG.ACT2_END, scrollProgress);
            const tC = smoothstep(CONFIG.ACT3_START, CONFIG.ACT3_END, scrollProgress);

            // Apply easing to morph transition
            const morphProgress = CONFIG.USE_REDUCED_MOTION ? tB : easeOutCubic(tB);

            // Drift is active in Act 1
            const driftActive = CONFIG.USE_REDUCED_MOTION ? 0 : (1 - morphProgress * 0.7);

            for (let i = 0; i < particleSprites.length; i++) {
                const sprite = particleSprites[i];
                const start = startPositions[i];
                const target = circlePositions[i];
                const drift = driftOffsets[i];
                const rotation = rotationOffsets[i];
                const offset = currentOffsets[i];

                // Update drift
                drift.x += drift.speedX * driftActive * CONFIG.DRIFT_AMOUNT;
                drift.y += drift.speedY * driftActive * CONFIG.DRIFT_AMOUNT;
                drift.z += drift.speedZ * driftActive * CONFIG.DRIFT_AMOUNT;

                // Morph from start to target position
                let x = mix(start.x, target.x, morphProgress);
                let y = mix(start.y, target.y, morphProgress);
                let z = mix(start.z, target.z, morphProgress);

                // Add drift offset
                x += drift.x * driftActive;
                y += drift.y * driftActive;
                z += drift.z * driftActive;

                // Add mouse repulsion offset
                x += offset.x;
                y += offset.y;
                z += offset.z;

                // Apply spring overshoot effect when forming circle
                if (morphProgress > 0.7 && !CONFIG.USE_REDUCED_MOTION) {
                    const overshoot = easeOutElastic(morphProgress);
                    x = mix(start.x, target.x, overshoot) + offset.x;
                    y = mix(start.y, target.y, overshoot) + offset.y;
                }

                // Explosion effect in Act 3
                if (tC > 0.1) {
                    const explosionProgress = easeOutCubic(tC);
                    const distance = Math.sqrt(target.x * target.x + target.y * target.y + target.z * target.z);
                    const direction = {
                        x: target.x / (distance || 1),
                        y: target.y / (distance || 1),
                        z: target.z / (distance || 1)
                    };

                    // Explode outward
                    const explosionDistance = explosionProgress * 15;
                    x += direction.x * explosionDistance;
                    y += direction.y * explosionDistance;
                    z += direction.z * explosionDistance;
                }

                // Update sprite position
                sprite.position.set(x, y, z);

                // 3D Rotation
                sprite.rotation.x += rotation.speedX;
                sprite.rotation.y += rotation.speedY;
                sprite.rotation.z += rotation.speedZ;

                // Scale based on Act 3 progress (fade and shrink during explosion)
                const scale = mix(1.0, 0.1, tC);
                sprite.scale.set(scale, scale, scale);

                // Update material opacity
                const opacity = mix(0.8, 0.0, tC);
                sprite.material.opacity = opacity;

                // Gradually decay offsets
                offset.x *= 0.95;
                offset.y *= 0.95;
                offset.z *= 0.95;
            }
        }

        /**
         * Apply mouse repulsion effect to nearby particles
         */
        function applyMouseRepulsion() {
            if (particleSprites.length === 0 || CONFIG.USE_REDUCED_MOTION) return;

            const radius = CONFIG.MOUSE_REPULSION_RADIUS;
            const strength = CONFIG.MOUSE_REPULSION_STRENGTH;
            const morphProgress = smoothstep(CONFIG.ACT2_START, CONFIG.ACT2_END, scrollProgress);

            for (let i = 0; i < particleSprites.length; i++) {
                const start = startPositions[i];
                const target = circlePositions[i];

                // Current position (interpolated)
                const currentX = mix(start.x, target.x, morphProgress);
                const currentY = mix(start.y, target.y, morphProgress);
                const currentZ = mix(start.z, target.z, morphProgress);

                // Distance to mouse
                const dx = currentX - mouse3D.x;
                const dy = currentY - mouse3D.y;
                const dz = currentZ - mouse3D.z;
                const distSq = dx * dx + dy * dy + dz * dz;
                const dist = Math.sqrt(distSq);

                if (dist < radius && dist > 0.01) {
                    // Calculate repulsion
                    const falloff = 1 - (dist / radius);
                    const force = falloff * falloff * strength;

                    currentOffsets[i].x += (dx / dist) * force;
                    currentOffsets[i].y += (dy / dist) * force;
                    currentOffsets[i].z += (dz / dist) * force;
                }
            }
        }

        /* ========================================
           SCROLL HANDLING
        ======================================== */

        /**
         * Update scroll progress and related UI
         */
        function updateScrollProgress() {
            const scrollY = window.scrollY || window.pageYOffset;
            const maxScroll = document.documentElement.scrollHeight - window.innerHeight;

            // Calculate normalized scroll progress [0, 1]
            scrollProgress = clamp(scrollY / maxScroll, 0, 1);

            // Hide scroll indicator after initial scroll
            const indicator = document.getElementById('scrollIndicator');
            if (scrollProgress > 0.1) {
                indicator.classList.add('hidden');
            } else {
                indicator.classList.remove('hidden');
            }

            // Show content section in Act 3
            const contentSection = document.querySelector('.content-section');
            const tC = smoothstep(CONFIG.ACT3_START, CONFIG.ACT3_END, scrollProgress);
            if (tC > 0.5) {
                contentSection.classList.add('visible');
            } else {
                contentSection.classList.remove('visible');
            }
        }

        /* ========================================
           CAMERA
        ======================================== */

        /**
         * Update camera position based on scroll and rotation
         */
        function updateCamera() {
            const tB = smoothstep(CONFIG.ACT2_START, CONFIG.ACT2_END, scrollProgress);
            const tC = smoothstep(CONFIG.ACT3_START, CONFIG.ACT3_END, scrollProgress);

            // Update camera radius based on scroll (zoom)
            let targetRadius = mix(CONFIG.CAMERA_START_Z, CONFIG.CAMERA_END_Z, tB);
            targetRadius = mix(targetRadius, CONFIG.CAMERA_START_Z - 5, tC);
            cameraRadius = targetRadius;

            // Apply velocity damping for smooth rotation
            cameraThetaVelocity *= CONFIG.ROTATION_DAMPING;
            cameraPhiVelocity *= CONFIG.ROTATION_DAMPING;

            // Update angles with velocity
            cameraTheta += cameraThetaVelocity;
            cameraPhi += cameraPhiVelocity;

            // Clamp phi to prevent camera from flipping (keep between 0.1 and PI - 0.1)
            cameraPhi = clamp(cameraPhi, 0.1, Math.PI - 0.1);

            // Convert spherical coordinates to Cartesian
            const x = cameraRadius * Math.sin(cameraPhi) * Math.sin(cameraTheta);
            const y = cameraRadius * Math.cos(cameraPhi);
            const z = cameraRadius * Math.sin(cameraPhi) * Math.cos(cameraTheta);

            // Update camera position
            camera.position.set(x, y, z);

            // Always look at the center (origin)
            camera.lookAt(0, 0, 0);
        }

        /* ========================================
           MOUSE TRACKING
        ======================================== */

        /**
         * Handle mouse down (start dragging)
         */
        function onMouseDown(event) {
            isDragging = true;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        }

        /**
         * Handle mouse up (stop dragging)
         */
        function onMouseUp(event) {
            isDragging = false;
        }

        /**
         * Update mouse position and handle camera rotation
         */
        function onMouseMove(event) {
            // Normalize to [-1, 1]
            mouseNDC.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouseNDC.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Convert to 3D space at camera depth
            mouse3D.set(
                mouseNDC.x * (camera.position.z * Math.tan(THREE.MathUtils.degToRad(CONFIG.CAMERA_FOV / 2)) * camera.aspect),
                mouseNDC.y * (camera.position.z * Math.tan(THREE.MathUtils.degToRad(CONFIG.CAMERA_FOV / 2))),
                0
            );

            // Handle camera rotation when dragging
            if (isDragging) {
                const deltaX = event.clientX - lastMouseX;
                const deltaY = event.clientY - lastMouseY;

                // Update camera rotation velocities
                cameraThetaVelocity += deltaX * CONFIG.ROTATION_SENSITIVITY;
                cameraPhiVelocity += deltaY * CONFIG.ROTATION_SENSITIVITY;

                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
            }
        }

        /* ========================================
           RESIZE HANDLING
        ======================================== */

        /**
         * Handle window resize
         */
        function onResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            renderer.setSize(width, height);
        }

        /* ========================================
           ANIMATION LOOP
        ======================================== */

        let lastTime = 0;

        /**
         * Main animation loop
         */
        function animate(currentTime) {
            requestAnimationFrame(animate);

            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            // Update based on scroll
            updateCamera();
            updateParticles(deltaTime);
            applyMouseRepulsion();

            // Render
            renderer.render(scene, camera);
        }

        /* ========================================
           INITIALIZATION
        ======================================== */

        /**
         * Initialize Three.js scene
         */
        function initScene() {
            // Get canvas element
            const canvas = document.getElementById('hero-canvas');

            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.BACKGROUND_COLOR);

            // Create camera
            camera = new THREE.PerspectiveCamera(
                CONFIG.CAMERA_FOV,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );

            // Set initial camera position using spherical coordinates
            const x = cameraRadius * Math.sin(cameraPhi) * Math.sin(cameraTheta);
            const y = cameraRadius * Math.cos(cameraPhi);
            const z = cameraRadius * Math.sin(cameraPhi) * Math.cos(cameraTheta);
            camera.position.set(x, y, z);
            camera.lookAt(0, 0, 0);

            // Create renderer
            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true,
                alpha: false
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // Add subtle ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            // Create particles
            createParticles();

            console.log('Scene initialized');
        }

        /* ========================================
           EVENT LISTENERS
        ======================================== */

        function setupEventListeners() {
            // Scroll
            window.addEventListener('scroll', updateScrollProgress, { passive: true });

            // Mouse events
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mouseup', onMouseUp);
            window.addEventListener('mousemove', onMouseMove);

            // Resize
            window.addEventListener('resize', onResize, { passive: true });

            // Initial scroll update
            updateScrollProgress();
        }

        /* ========================================
           ENTRY POINT
        ======================================== */

        /**
         * Initialize when DOM is ready
         */
        function init() {
            console.log('Initializing Three.js scroll hero...');
            console.log('Configuration:', CONFIG);

            initScene();
            setupEventListeners();
            animate(0);

            console.log('Animation started');
        }

        // Wait for DOM and Three.js to be ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
